# Спецификация QORP

## Аннотация
QORP (Quite Ok Routing Protocol) это реактивный протол динамической маршрутизации третьего уровня OSI 
предназначеный для организации ad hoc mesh-сетей без какой либо конфигурации (в прямом режиме) 
или с минимальной конфигурацией (в оверлейном режиме поверх интернета). 
Протокол обеспечивает приватность передаваемых данных и равномерное криптографическое распредленеие адресов без единого центра координации.

## Лицензирование
<p>
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    <br />
    Данная спецификация распространяется под лицензией <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</p>

## Мотивация
Задача построения распределенной mesh-сети лишеной единых точек отказа, устойчивой к динамическому изменению топологии и защищенной криптографически достаточно давно стоит в сообществе сетевых энтузиастов. Однако все решения этой задачи известные на текущий момент страдают от оверинжиниринга и черезвычайно усложнены в попытках приблизиться к идеалу. Также из их сложности проистекает их плохая задокументированность и большие запутанные кодовые базы реализаций. QORP не стремиться быть идеальным, ведь лучшее - враг хорошего. Вместо этого он старается быть просто достаточно хорошим решением, при этом оставаясь простым как для понимания, так и для реализации.

## Версионирование
В описании протокола маршрутизации QORP используется [семантическое версионирование](https://semver.org/lang/ru/).  
Мажорная версия увеличивается при внесении значителньх, **не** обратносовместимых изменений.  
Минорная версия увеличивается при внесении значительных **но** обратносовместимых ихменений.  
Патч версия увеличивается при внесении любых других изменений в протокол.  
Версии **не** увеличиваются при внесении уточнений, исправлении текстовых ошибок и других изменениях документа но не логики проткола.  
Протоколы транспортных соединений, протоколы делегирования управления маршрутизацией, протокол IPv6 поверх QORP и т.д. описываются в отдельных файлах и верисонируются отакже отдельно.  
Текущая версия протокола `0.0.1`  

## Терминология
Ключевые cлова **"ДОЛЖЕН" (MUST)**, **"НЕ ДОЛЖЕН» (MUST NOT)"**, **"ОБЯЗАТЕЛЬНО" (REQUIRED)**, **"СЛЕДУЕТ" (SHOULD)**, **"НЕ СЛЕДУЕТ" (SHOULD NOT)**, **"РЕКОМЕНДОВАННЫЙ" (RECOMMENDED)**, **"МОЖЕТ" (MAY)** и **"НЕОБЯЗАТЕЛЬНЫЙ" (OPTIONAL)** в этом документе должны быть интерпретированы в соответствии с [IETF RFC 2119](http://www.ietf.org/rfc/rfc2119.txt).  

**Узел(node)** - самодостаточный элемент сети. Узлы так или иначе соединяются друг с другом образуя **сеть** 
и действуют согласно протоколу **QORP** чтобы обеспечить доставку **пакетов** между друг другом.
  
**Сеть** - совокупность **узлов** соедиенных друг с другом.
  
**Пир(peer)** - эквивалент термина **узел** используемый когда речь идет о двух узлах между которыми есть **прямое соединение**. 
  
**Прямое соединение** также **транспортное соединение** - непосредственное соединение между двумя **узлами** **сети** вне самой **сети**. 
Может осуществляться поверх других протоколов и сетей.
  
**Пакет** - массив данных в двоичный форме имеющий конечную длину и передающийся между **узлами**.
  
**Маршрут** - последовательность **прямых соединений** между **узлами** через которые **пакет** должен пройти чтобы попасть от одного **узла** к другому. 

**Отправитель** - **узел** который создает и отправляет пакет в **сеть**.

**Получатель** - **узел** которому предназначается **пакет**.

**Транзитный/промежуточный узел** - **узел** который лежит на маршруте между **отправителем** и **получателем**.

## Алгоритм маршрутизации

### Абстракция соединения
Здесь и далее при описании логики маршрутизации QORP упоминается **канал**. Под **каналом** прониматся абстракци над **прямым соединением**.  
Пока **канал** существует, в него могут отправляться **пакеты** и из него могут получаться **пакеты**.  
Абстракция канала не предоставляет гарантий доставки/целостности/упорядоченности пакетов.  
**Каналы** создаются и уничтожаются логикой внешней относительно логики маршртуизации.  
О **канале** не известно ничего кроме того что по ту сторону канала находится другой **узел**.  

### Поиск маршрута
Когда одному **узлу**(обозначим как *А*) требуется передать данные другому **узлу**(обозначим как *Б*), ему требуется найти для этого **маршрут** в **сети**.  
Для этого, **узел** *А* отправляет **пакет** с запросом поиска маршрута в каждый открытый **канал** который у него имеется.  
Каждый **узел**, получивший этот **пакет**, если он не является **узлом** *Б*, перенаправляет этот пакет также во все свои каналы кроме того, из которого **пакет** был получен.  
   
Когда **пакет** поиска маршрута достигает **узла** *Б*, **узел** *Б* отвечает **пакетом** подтверждения маршрута, который доставляется обратно к **узлу** *А*, по пути пройденому **пакетом** поиска маршрута.  
После этого **маршрут** от *А* к *Б* считается согласованным и по нему могут передаваться пакеты с полезной нагрузкой.  

### Передача данных
**Узел** *А* формирует криптографически защищенные (как это описывается ниже) **пакеты** с данными и передает их по **маршруту** согласованному на прошлом этапе.

### Отклонение маршртуа
Если **узел** через котоырй идет траффик от **узла** *А* к **узлу** *Б*, обнаружает, что **канал** через который ему следует переслать **пакет** с данными дальше больше не существует, он формирует **пакет** с сообщением об ошибке маршрутизации и отправляет его обратно по пути к **узлу** *А*.  
Каждый промежуточный **узел**, через который проходит **пакет** ошибки маршрутизации, а также сам **узел** *А*, помечают **канал** откуда пришел этот **пакет** как более не подходящий для доставки **пакетов** к **узлу** *Б*.  
Если по получению **пакета** ошибки маршрутизации **узел** *А* обнаружает что у него более нет известных **маршрутов** для доставки **пакетов** к **узлу** *Б*, то он повторно инициирует процедуру поиска **маршрута**.

## Криптография

### Используемые криптографические примитивы

+ [ChaCha20](https://cr.yp.to/chacha.html) для симметричного шифрования, аутентифицированный [Poly1305](https://cr.yp.to/mac.html), с использованием [RFC7539's AEAD](https://www.rfc-editor.org/rfc/rfc7539)
+ [Curve25519](http://cr.yp.to/ecdh.html) для ECDHE
+ EdDSA
+ [HKDF](https://eprint.iacr.org/2010/264) для деривации ключей, как это описано в [RFC5869](https://www.rfc-editor.org/rfc/rfc5869)

### Применение криптографии в протколе
Каждый **узел** однозначно идентифицируется парой из публичного и приватного ключа EdDSA.  
При взаимодействии между **узлами** в **сети** для идентификации используется публичный ключ, целиком, либо его часть.  
Во время процедуры поиска маршрута **узлами** **отправителем** и **получателем** генерируются пары эфимерных ключей Curve25519, на основании которых через процедуру ECDHE вырабатывается общий секрет.  
**Пакеты** с полезной нагрузкой отправляемые в последствии шифруются ChaCha20 c общим секретом пропущеным через HKDF и аутентифицируются Poly1305 AEAD.  

## Структура пакетов

### RouteRequest
Поля:
| № | Имя         | Смещение | Длина    | Описание                                                                      |
| - | ----------- | -------- | -------- | ----------------------------------------------------------------------------- |
| 0 | PackageType | 0 байт   | 1 байт   | Тип пакета; Константа 0                                                       |
| 1 | Destination | 1 байт   | 16 байт  | *Первые* 128 бит публичного ключа **получателя**                              |
| 2 | Source      | 17 байт  | 32 байта | Полный публичный ключ **отправителя**                                         |
| 3 | RID         | 49 байт  | 8 байт   | Идентификатор запроса                                                         |
| 4 | SourceEph   | 57 байт  | 32 байта | Эфемерный публичный ключ **отправителя**                                      |
| 5 | sign        | 89 байт  | 64 байта | Подпись EdDSA **отправителя** рассчитанная от конкатенинации предыдущих полей |
| 6 | TTL         | 153 байт | 1 байт   | Ограничение на колличество узлов пройденных пакетом                           |

**Узел** **ДОЛЖЕН**(MUST) генерировать новую эфемерную пару ключей Curve25519 *каждый* раз при формировании нового RouteRequest **пакета**.  
**Узел** **ДОЛЖЕН**(MUST) инкрементировать RID *каждый* раз при формировании нового RouteRequest **пакета**.  
Подпись рассчитывается для фргамента сообщения c 0 по 88 байт включительно.  
Рекомендуется инициализировать TTL значением 64.  

### RouteResponce
Поля:
| № | Имя         | Смещение | Длина    | Описание                                                                      |
| - | ----------- | -------- | -------- | ----------------------------------------------------------------------------- |
| 0 | PackageType | 0 байт   | 1 байт   | Тип пакета; Константа 1                                                       |
| 1 | Destination | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **получателя**                           |
| 2 | Source      | 17 байт  | 32 байта | Полный публичный ключ **отправителя**                                         |
| 3 | RID         | 49 байт  | 8 байт   | Идентификатор запроса                                                         |
| 4 | SourceEph   | 57 байт  | 32 байта | Эфемерный публичный ключ **отправителя**                                      |
| 5 | SID         | 89 байт  | 4 байта  | Идентификатор сессии                                                          |
| 6 | sign        | 93 байт  | 64 байта | Подпись EdDSA **отправителя** рассчитанная от конкатенинации предыдущих полей |

**Узел** **ДОЛЖЕН**(MUST) генерировать новую эфемерную пару ключей Curve25519 *каждый* раз при формировании нового RouteResponce **пакета**.  
**Узел** **ДОЛЖЕН**(MUST) использовать RID из того RouteRequest **пакета** на который он отвечает этим RouteResponce **пакетом**.  
**Узел** **ДОЛЖЕН**(MUST) сгененрировать SID таким образом, чтобы у него не было одновременно нескольких активных сессий с одинаковыми SID.   
Подпись рассчитывается для фргамента сообщения c 0 по 92 байт включительно.  

### RouteError
Поля:
| № | Имя             | Смещение | Длина    | Описание                                                                |
| - | --------------- | -------- | -------- | ----------------------------------------------------------------------- |
| 0 | PackageType     | 0 байт   | 1 байт   | Тип пакета; Константа 2                                                 |
| 1 | UnreachableNode | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **узла** который более не достижим |

### NetData
Поля:
| № | Имя             | Смещение | Длина    | Описание                                            |
| - | --------------- | -------- | -------- | --------------------------------------------------- |
| 0 | PackageType     | 0 байт   | 1 байт   | Тип пакета; Константа 3                             |
| 1 | Destination     | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **получателя** |
| 2 | SID             | 17 байт  | 4 байта  | Идентификатор сессии                                |
| 3 | Payload         | 21 байт  | N байт   | Зашифрованная полезная нагрузка                     |

**Узел** **ДОЛЖЕН**(MUST) использовать SID из последнего RouteResponce или UpdateKeysResponce **пакета** возвращенного **получателем**.  

### UpdateKeysRequest
Поля:
| № | Имя             | Смещение | Длина    | Описание                                            |
| - | --------------- | -------- | -------- | --------------------------------------------------- |
| 0 | PackageType     | 0 байт   | 1 байт   | Тип пакета; Константа 4                             |
| 1 | Destination     | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **получателя** |
| 2 | SID             | 17 байт  | 4 байта  | Идентификатор сессии                                |
| 3 | Payload         | 21 байт  | N байт   | Зашифрованная полезная нагрузка                     |

Вложенные поля, внутри поля Payload:
| № | Имя         | Смещение | Длина    | Описание                                       |
| - | ----------- | -------- | -------- | ---------------------------------------------- |
| 0 | RID         | 0 байт  | 8 байт   | Идентификатор запроса                          |
| 1 | SourceEph   | 8 байт  | 32 байта | Новый эфемерный публичный ключ **отправителя** |

**Узел** **ДОЛЖЕН**(MUST) использовать SID из последнего RouteResponce или UpdateKeysResponce **пакета** возвращенного **получателем**.  
**Узел** **ДОЛЖЕН**(MUST) генерировать новую эфемерную пару ключей Curve25519 *каждый* раз при формировании нового UpdateKeysRequest **пакета**.  
**Узел** **ДОЛЖЕН**(MUST) инкрементировать RID *каждый* раз при формировании нового UpdateKeysRequest **пакета**.  

### UpdateKeysResponce
Поля:
| № | Имя             | Смещение | Длина    | Описание                                            |
| - | --------------- | -------- | -------- | --------------------------------------------------- |
| 0 | PackageType     | 0 байт   | 1 байт   | Тип пакета; Константа 5                             |
| 1 | Destination     | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **получателя** |
| 2 | OldSID          | 17 байт  | 4 байта  | Старый идентификатор сессии                         |
| 3 | Payload         | 21 байт  | N байт   | Зашифрованная полезная нагрузка                     |

Вложенные поля, внутри поля Payload:
| № | Имя         | Смещение | Длина    | Описание                                       |
| - | ----------- | -------- | -------- | ---------------------------------------------- |
| 0 | RID         | 0 байт  | 8 байт    | Идентификатор запроса                          |
| 1 | NewSID      | 8 байт  | 8 байт    | Новый идентификатор сессии                     |
| 2 | SourceEph   | 16 байт  | 32 байта | Новый эфемерный публичный ключ **отправителя** |

**Узел** **ДОЛЖЕН**(MUST) генерировать новую эфемерную пару ключей Curve25519 *каждый* раз при формировании нового UpdateKeysResponce **пакета**.  
**Узел** **ДОЛЖЕН**(MUST) использовать RID из того UpdateKeysRequest **пакета** на который он отвечает этим UpdateKeysResponce **пакетом**.  
**Узел** **ДОЛЖЕН**(MUST) сгененрировать SID таким образом, чтобы у него не было одновременно нескольких активных сессий с одинаковыми SID.   

## Модель поведения узла

## Инвалидация кеша

## Объяснение решений

## Транспорты

## Методы атаки на сеть и способы противодействия им

## Рекомендации для реализаций

- ограничение MTU

# Спецификация QORP

## Аннотация
QORP (Quite Ok Routing Protocol) это реактивный протол динамической маршрутизации третьего уровня OSI 
предназначеный для организации ad hoc mesh-сетей без какой либо конфигурации (в прямом режиме) 
или с минимальной конфигурацией (в оверлейном режиме поверх интернета). 
Протокол обеспечивает приватность передаваемых данных и равномерное криптографическое распредленеие адресов без единого центра координации.

## Лицензирование
<p>
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    <br />
    Данная спецификация распространяется под лицензией <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</p>

## Мотивация
Задача построения распределенной mesh-сети лишеной единых точек отказа, устойчивой к динамическому изменению топологии и защищенной криптографически достаточно давно стоит в сообществе сетевых энтузиастов. Однако все решения этой задачи известные на текущий момент страдают от оверинжиниринга и черезвычайно усложнены в попытках приблизиться к идеалу. Также из их сложности проистекает их плохая задокументированность и большие запутанные кодовые базы реализаций. QORP не стремиться быть идеальным, ведь лучшее - враг хорошего. Вместо этого он старается быть просто достаточно хорошим решением, при этом оставаясь простым как для понимания, так и для реализации.

## Версионирование
В описании протокола маршрутизации QORP используется [семантическое версионирование](https://semver.org/lang/ru/).  
Мажорная версия увеличивается при внесении значителньх, **не** обратносовместимых изменений.  
Минорная версия увеличивается при внесении значительных **но** обратносовместимых ихменений.  
Патч версия увеличивается при внесении любых других изменений в протокол.  
Версии **не** увеличиваются при внесении уточнений, исправлении текстовых ошибок и других изменениях документа но не логики проткола.  
Протоколы транспортных соединений, протоколы делегирования управления маршрутизацией, протокол IPv6 поверх QORP и т.д. описываются в отдельных файлах и верисонируются отакже отдельно.  
Текущая версия протокола `0.0.1`  

## Терминология
Ключевые cлова **"ДОЛЖЕН" (MUST)**, **"НЕ ДОЛЖЕН» (MUST NOT)"**, **"ОБЯЗАТЕЛЬНО" (REQUIRED)**, **"СЛЕДУЕТ" (SHOULD)**, **"НЕ СЛЕДУЕТ" (SHOULD NOT)**, **"РЕКОМЕНДОВАННЫЙ" (RECOMMENDED)**, **"МОЖЕТ" (MAY)** и **"НЕОБЯЗАТЕЛЬНЫЙ" (OPTIONAL)** в этом документе должны быть интерпретированы в соответствии с [IETF RFC 2119](http://www.ietf.org/rfc/rfc2119.txt).  

**Узел(node)** - самодостаточный элемент сети. Узлы так или иначе соединяются друг с другом образуя **сеть** 
и действуют согласно протоколу **QORP** чтобы обеспечить доставку **пакетов** между друг другом.
  
**Сеть** - совокупность **узлов** соедиенных друг с другом.
  
**Пир(peer)** - эквивалент термина **узел** используемый когда речь идет о двух узлах между которыми есть **прямое соединение**. 
  
**Прямое соединение** также **транспортное соединение** - непосредственное соединение между двумя **узлами** **сети** вне самой **сети**. 
Может осуществляться поверх других протоколов и сетей.
  
**Пакет** - массив байт определённой структуры, имеющий конечную длину и передающийся между **узлами**.
  
**Маршрут** - последовательность **прямых соединений** между **узлами** через которые **пакет** должен пройти чтобы попасть от одного **узла** к другому. 

**Отправитель** - **узел** который создает и отправляет пакет в **сеть**.

**Получатель** - **узел** которому предназначается **пакет**.

**Транзитный/промежуточный узел** - **узел** который лежит на маршруте между **отправителем** и **получателем**.

## Алгоритм маршрутизации

### Абстракция соединения
Здесь и далее при описании логики маршрутизации QORP упоминается **канал**. Под **каналом** прониматся абстракци над **прямым соединением**.  
Пока **канал** существует, в него могут отправляться **пакеты** и из него могут получаться **пакеты**.  
Абстракция канала не предоставляет гарантий доставки/целостности/упорядоченности пакетов.  
**Каналы** создаются и уничтожаются логикой внешней относительно логики маршртуизации.  
О **канале** не известно ничего кроме того что по ту сторону канала находится другой **узел**.  

### Поиск маршрута
Когда одному **узлу**(обозначим как *А*) требуется передать данные другому **узлу**(обозначим как *Б*), ему требуется найти для этого **маршрут** в **сети**.  
Для этого, **узел** *А* отправляет **пакет** с запросом поиска маршрута в каждый открытый **канал** который у него имеется.  
Каждый **узел**, получивший этот **пакет**, если он не является **узлом** *Б*, перенаправляет этот пакет также во все свои каналы кроме того, из которого **пакет** был получен, используя технику split horizon.  
   
Когда **пакет** поиска маршрута достигает **узла** *Б*, **узел** *Б* отвечает **пакетом** подтверждения маршрута, который доставляется обратно к **узлу** *А*, по пути пройденому **пакетом** поиска маршрута.  
После этого **маршрут** от *А* к *Б* считается согласованным и по нему могут передаваться пакеты с полезной нагрузкой.  

### Передача данных
**Узел** *А* формирует криптографически защищенные (как это описывается ниже) **пакеты** с данными и передает их по **маршруту** согласованному на прошлом этапе.

### Отклонение маршртуа
Если **узел** через котоырй идет траффик от **узла** *А* к **узлу** *Б*, обнаружает, что **канал** через который ему следует переслать **пакет** с данными дальше больше не существует, он формирует **пакет** с сообщением об ошибке маршрутизации и отправляет его обратно по пути к **узлу** *А*.  
Каждый промежуточный **узел**, через который проходит **пакет** ошибки маршрутизации, а также сам **узел** *А*, помечают **канал** откуда пришел этот **пакет** как более не подходящий для доставки **пакетов** к **узлу** *Б*.  
Если по получению **пакета** ошибки маршрутизации **узел** *А* обнаружает что у него более нет известных **маршрутов** для доставки **пакетов** к **узлу** *Б*, то он повторно инициирует процедуру поиска **маршрута**.

## Криптография

### Используемые криптографические примитивы

+ [ChaCha20](https://cr.yp.to/chacha.html) для симметричного шифрования, аутентифицированный [Poly1305](https://cr.yp.to/mac.html), с использованием [RFC7539's AEAD](https://www.rfc-editor.org/rfc/rfc7539)
+ [Curve25519](http://cr.yp.to/ecdh.html) для ECDHE
+ EdDSA
+ [HKDF](https://eprint.iacr.org/2010/264) для деривации ключей, как это описано в [RFC5869](https://www.rfc-editor.org/rfc/rfc5869)

### Применение криптографии в протколе
Каждый **узел** однозначно идентифицируется парой из публичного и приватного ключа EdDSA.  
При взаимодействии между **узлами** в **сети** для идентификации используется публичный ключ, целиком, либо его часть.  
Во время процедуры поиска маршрута **узлами** **отправителем** и **получателем** генерируются пары эфимерных ключей Curve25519, на основании которых через процедуру ECDHE вырабатывается общий секрет.  
**Пакеты** с полезной нагрузкой отправляемые в последствии шифруются ChaCha20 и аутентифицируются Poly1305 AEAD.  
При генерации ключа для симметричного шифрования используется HKDF функция над общим секретом и всеми значениями полей **пакетов** запроса маршрута и ответа на запрос маршрута.  

## Сессия
Здесь и далее под сессией подразумевается состояние в которое два узла переходят после обмена пакетами запроса маршрута и ответа на запрос маршрута.  
  
Иниициатор сессии - узел который отправляет пакет поиска маршрута.  
  
Приемник сессии - узел который отвечает на пакет поиска маршрута инициатора.
  
Ключ сесии - симметричный ключ шифрования используемый в пределах этой сессии.  
  
Идентификатор сессии или SID - 64 битное чило, выбираемое приемником сесии и однозначно идентифицирующее ее для приемника.  
  
Открытие сесии - согласование SID и ключа сессии двумя узлами.  
  
Закрытие сесии - односторонее удаление информации о сессии узлом.  
  
Одновременно у двух узлов может быть только по одной активной сессии в каждом направлении (от первого ко второму и от второго к первому). 
Существующая сессия может быть пересоздана путем обмена специальными служебными пакетами либо повторной процедурой поиска маршрута, что влечет за собой выработку нового SID и нового ключа сессии.  
Однако в виду отсутвия гарантии порядка доставки пакетов в сети, пакеты отправленные инициатором до пересоздания сессии могут достигнуть приемника уже помсле него.  
Для сохранения возможности расшифровки приемником таких *запоздалых* пакетов СЛЕДУЕТ хранить устаревшие ключи и идентификаторы сессии некоторое время прежде чем удалять их.  
  
Как уже было указано выше, SID однозначно идентифицирует сессию для приемника.  
Для инициатора же, сессия однозначно идентифицируется адресом приемника т.к. не допускается существование более чем одной сессии в направлени от инициатора к приемнику одновременно.  
  
Сессиия может быть прекращена по одной из следующих причин:
+ При ичерпании пространства возможных значений SID и необходимости принять новую сессию, приемник может закрыть одну из уже существующих.
+ Инициатор может закрыть либо пересоздать сессию, в случае если у него не останется известных маршрутов до приемника.

## Структура пакетов

### RouteRequest
Поля:
| № | Имя         | Смещение | Длина    | Описание                                                                      |
| - | ----------- | -------- | -------- | ----------------------------------------------------------------------------- |
| 0 | PackageType | 0 байт   | 1 байт   | Тип пакета; Константа 0                                                       |
| 1 | Destination | 1 байт   | 16 байт  | *Первые* 128 бит публичного ключа **получателя**                              |
| 2 | Source      | 17 байт  | 32 байта | Полный публичный ключ **отправителя**                                         |
| 3 | RID         | 49 байт  | 8 байт   | Идентификатор запроса                                                         |
| 4 | SourceEph   | 57 байт  | 32 байта | Эфемерный публичный ключ **отправителя**                                      |
| 5 | Sign        | 89 байт  | 64 байта | Подпись EdDSA **отправителя** рассчитанная от конкатенинации предыдущих полей |
| 6 | TTL         | 153 байт | 1 байт   | Ограничение на колличество узлов пройденных пакетом                           |
| 7 | STTL        | 154 байт | 1 байт   | Стартовое значение TTL                                                        |

**Узел** **ДОЛЖЕН**(MUST) генерировать новую эфемерную пару ключей Curve25519 *каждый* раз при формировании нового RouteRequest **пакета**.  
**Узел** **ДОЛЖЕН**(MUST) инкрементировать RID *каждый* раз при формировании нового RouteRequest **пакета**.  
Подпись рассчитывается для фргамента сообщения c 0 по 88 байт включительно.  
Рекомендуется инициализировать TTL значением 64.  

### RouteResponce
Поля:
| № | Имя         | Смещение | Длина    | Описание                                                                      |
| - | ----------- | -------- | -------- | ----------------------------------------------------------------------------- |
| 0 | PackageType | 0 байт   | 1 байт   | Тип пакета; Константа 1                                                       |
| 1 | Destination | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **получателя**                           |
| 2 | Source      | 17 байт  | 32 байта | Полный публичный ключ **отправителя**                                         |
| 3 | RID         | 49 байт  | 8 байт   | Идентификатор запроса                                                         |
| 4 | SourceEph   | 57 байт  | 32 байта | Эфемерный публичный ключ **отправителя**                                      |
| 5 | SID         | 89 байт  | 4 байта  | Идентификатор сессии                                                          |
| 6 | Sign        | 93 байт  | 64 байта | Подпись EdDSA **отправителя** рассчитанная от конкатенинации предыдущих полей |
| 6 | TTL         | 157 байт | 1 байт   | Ограничение на колличество узлов пройденных пакетом                           |

**Узел** **ДОЛЖЕН**(MUST) генерировать новую эфемерную пару ключей Curve25519 *каждый* раз при формировании нового RouteResponce **пакета**.  
**Узел** **ДОЛЖЕН**(MUST) использовать RID из того RouteRequest **пакета** на который он отвечает этим RouteResponce **пакетом**.  
**Узел** **ДОЛЖЕН**(MUST) сгененрировать SID таким образом, чтобы у него не было одновременно нескольких активных сессий с одинаковыми SID.   
Подпись рассчитывается для фргамента сообщения c 0 по 92 байт включительно.  

### RouteError
Поля:
| № | Имя             | Смещение | Длина    | Описание                                                                             |
| - | --------------- | -------- | -------- | ------------------------------------------------------------------------------------ |
| 0 | PackageType     | 0 байт   | 1 байт   | Тип пакета; Константа 2                                                              |
| 1 | UnreachableNode | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **узла** который более не достижим              |
| 2 | UnreachableFor  | 17 байт  | 16 байт  | *Последние* 128 бит публичного ключа **узла** для которого маршрут более не достижим |

### NetData
Поля:
| № | Имя             | Смещение | Длина    | Описание                                            |
| - | --------------- | -------- | -------- | --------------------------------------------------- |
| 0 | PackageType     | 0 байт   | 1 байт   | Тип пакета; Константа 3                             |
| 1 | Destination     | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **получателя** |
| 2 | SID             | 17 байт  | 4 байта  | Идентификатор сессии                                |
| 3 | Nonce           | 21 байт  | 12 байт  | ChaCha20-Poly1305 Nonce                             |
| 4 | Payload         | 33 байт  | N байт   | Зашифрованная полезная нагрузка                     |

**Узел** **ДОЛЖЕН**(MUST) использовать SID из последнего RouteResponce или UpdateKeysResponce **пакета** возвращенного **получателем**.  

### UpdateKeysRequest
Поля:
| № | Имя             | Смещение | Длина    | Описание                                            |
| - | --------------- | -------- | -------- | --------------------------------------------------- |
| 0 | PackageType     | 0 байт   | 1 байт   | Тип пакета; Константа 4                             |
| 1 | Destination     | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **получателя** |
| 2 | SID             | 17 байт  | 4 байта  | Идентификатор сессии                                |
| 3 | Nonce           | 21 байт  | 12 байт  | ChaCha20-Poly1305 Nonce                             |
| 4 | Payload         | 33 байт  | N байт   | Зашифрованная полезная нагрузка                     |

Вложенные поля, внутри поля Payload:
| № | Имя         | Смещение | Длина    | Описание                                       |
| - | ----------- | -------- | -------- | ---------------------------------------------- |
| 0 | RID         | 0 байт   | 8 байт   | Идентификатор запроса                          |
| 1 | SourceEph   | 8 байт   | 32 байта | Новый эфемерный публичный ключ **отправителя** |

**Узел** **ДОЛЖЕН**(MUST) использовать SID из последнего RouteResponce или UpdateKeysResponce **пакета** возвращенного **получателем**.  
**Узел** **ДОЛЖЕН**(MUST) генерировать новую эфемерную пару ключей Curve25519 *каждый* раз при формировании нового UpdateKeysRequest **пакета**.  
**Узел** **ДОЛЖЕН**(MUST) инкрементировать RID *каждый* раз при формировании нового UpdateKeysRequest **пакета**.  

### UpdateKeysResponce
Поля:
| № | Имя             | Смещение | Длина    | Описание                                            |
| - | --------------- | -------- | -------- | --------------------------------------------------- |
| 0 | PackageType     | 0 байт   | 1 байт   | Тип пакета; Константа 5                             |
| 1 | Destination     | 1 байт   | 16 байт  | *Последние* 128 бит публичного ключа **получателя** |
| 2 | OldSID          | 17 байт  | 4 байта  | Старый идентификатор сессии                         |
| 3 | Nonce           | 21 байт  | 12 байт  | ChaCha20-Poly1305 Nonce                             |
| 4 | Payload         | 33 байт  | N байт   | Зашифрованная полезная нагрузка                     |

Вложенные поля, внутри поля Payload:
| № | Имя         | Смещение | Длина    | Описание                                       |
| - | ----------- | -------- | -------- | ---------------------------------------------- |
| 0 | RID         | 0 байт   | 8 байт   | Идентификатор запроса                          |
| 1 | NewSID      | 8 байт   | 8 байт   | Новый идентификатор сессии                     |
| 2 | SourceEph   | 16 байт  | 32 байта | Новый эфемерный публичный ключ **отправителя** |

**Узел** **ДОЛЖЕН**(MUST) генерировать новую эфемерную пару ключей Curve25519 *каждый* раз при формировании нового UpdateKeysResponce **пакета**.  
**Узел** **ДОЛЖЕН**(MUST) использовать RID из того UpdateKeysRequest **пакета** на который он отвечает этим UpdateKeysResponce **пакетом**.  
**Узел** **ДОЛЖЕН**(MUST) сгененрировать SID таким образом, чтобы у него не было одновременно нескольких активных сессий с одинаковыми SID.   

## Модель поведения узла

### Ограничения модели
В приведенной ниже модели допускается что **узлы** имеют неограниченный объем памяти для хранения состояния. Рекомендации о действиях в условиях конечных объемов памяти предлагаются в главах [Инвалидация кеша](#инвалидация-кеша) и [Рекомендации для реализаций](#рекомендации-для-реализаций).  
  
Приведена ниже модель и в особенности та ее часть, что описывает внутреннее состояние, спроектированна для наглядности и не является оптимальной с точки зрения практического применения.  

### Внутреннее состояние
Каждый **узел** в процессе работы сохраняет следующую информацию:  

#### TransitCache (Кеш транзитных RouteRequest и RouteResponce пакетов)
Представлен списком всех пакетов поиска маршрута которые прошли через **узел** и для которых 
он не являлся ни **адресатом**, ни **отправителем**.  
Данный кеш используется для отбрасывания мусорных RouteRequest и RouteResponce пакетов для защиты от reply атак 
и выполнения техники split horizon.  

#### RoutingTable (Таблица маршрутизации)
Поля:
| Имя      | Описание                                                                                                  |
| -------- | --------------------------------------------------------------------------------------------------------- |
| From     | Адрес отправителя пакета                                                                                  |
| To       | Адрес получателя пакета                                                                                   |
| RID      | Идентификатор запроса RouteRequest посредством которого был установлен этот маршрут                       |
| Incoming | Массив каналов из которых пакет от этого **отправителя** и для этого **получателя** может быть получен    |
| Outgoing | Массив каналов в которые пакет от этого **отправителя** и для этого **получателя** может быть переправлен |

Outgoing массив отсортирован так, что соединения из которых RouteResponce ответ с соответствующим RID пришел раньше, находятся ближе к началу, чем те из которых он пришел пойзже.  
  
Таблица маршрутизации формируется на основе пар связанных транзитных пакетов RouteRequest-RouteResponce.  

#### IncomingSessions (Таблица входящих сессий)
Поля:
| Имя       | Описание                                                          |
| --------- | ----------------------------------------------------------------- |
| SID       | Адрес отправителя пакета                                          |
| Key       | Ключ симметричного шифрования для расшифровки входящих пакетов    |
| Source    | Последние 128 бит публичного ключа узла, установившего эту сессию |
| TimeStamp | Время установки сессии                                            |


#### OutgoingSessions (Таблица исходящих сессий)
Поля:
| Имя             | Описание                                                                                |
| --------------- | --------------------------------------------------------------------------------------- |
| Destination     | Первые 128 бит публичного ключа узла c которым установлена либо устонавливается сессиия |
| DestinationFull | Полный публичный ключ узла с которым установлена либо устонавливается сессиия           |
| EphKey          | Приватный эфемерный кbgp fsm modelлюч сгенеhированный для установки этой сессии         |
| SID             | Идентификатор сессии                                                                    |
| Key             | Симметричный ключ шифрования сессии                                                     |

### Описание на псевдокоде
```
при каждом событии
    если это событие получения пакета от другого узла
        если текущий узел является получателем
            если тип пакета RouteRequest
                ..
            если тип пакета RouteResponce
                ..
            если тип пакета RouteError
                ..
            если тип пакета NetData
                ..
            если тип пакета UpdateKeysRequest
                ..
            если тип пакета UpdateKeysResponce
                ..
        если текущий узел не является получателем
            ..
    если это событие закрытия канала
        для каждой записи в таблице маршрутизации
            если канал есть в массиве Incoming
                удалить из массива Incoming
            если канал есть в массиве Outgoing
                удалить из массива Outgoing
                если массив Outgoing опустел
                    для каждого канала в массиве Incoming
                        удалить канал из массива Incoming
                        отправить в канал пакет RouteError{ UnreachableNode = To, UnreachableFor = From }
    если это событие получения данных которые требуется передать другому узлу
        ..
```

### FSM модель
```mermaid
graph TD
    %% States
    WaitEvent(Ожидание события)
    PackageProcessing(Обработка пакета)
    ClosingConnection(Обработка закрытия соединения)
    SendingData(Пересылка данных)
    %% State changes
    WaitEvent ==> |Получен пакет от другого узла| PackageProcessing
    WaitEvent ==> |Закрылось соединение| ClosingConnection
    WaitEvent ==> |Получены данные для пересылки другому узлу| SendingData
    %% ClosingConnection logic
    ClosingConnection_LoopOnRoutingTable{Еще есть элемент}
    ClosingConnection_Closed[Обработка завершена]
    ClosingConnection --> |Для каждой строки в таблице маршрутизации| ClosingConnection_LoopOnRoutingTable
    ClosingConnection_LoopOnRoutingTable --> |Нет| ClosingConnection_Closed
    ClosingConnection_Closed ==> WaitEvent
```

## Инвалидация кеша

## Расширения протокола

## Объяснение решений

## Транспорты

## Методы атаки на сеть и способы противодействия им

## Рекомендации для реализаций

- ограничение MTU
bgp fsm model
